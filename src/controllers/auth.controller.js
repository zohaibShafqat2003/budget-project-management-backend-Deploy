const { User, RefreshToken } = require('../models');
const jwt = require('jsonwebtoken');
const { JWT_SECRET, JWT_REFRESH_SECRET, JWT_EXPIRES_IN, JWT_REFRESH_EXPIRES_IN } = process.env;

// Register a new user
exports.register = async (req, res, next) => {
  try {
    const { email, password, firstName, lastName, role } = req.body;
    
    // Check if user already exists
    const existingUser = await User.findOne({
      where: {
        email
      }
    });
    
    if (existingUser) {
      return res.status(400).json({
        success: false,
        message: 'User already exists with this email'
      });
    }
    
    // Create user - password hashing is handled by the User model hooks
    const user = await User.create({
      email,
      password, // Will be hashed by the model hook
      firstName,
      lastName,
      role: role || 'Developer' // Default role
    });
    
    // Generate tokens
    const { accessToken, refreshToken } = generateTokens(user);
    
    // Save refresh token to RefreshToken model
    const expiresAt = new Date();
    // Parse refresh token expiration
    const refreshExpireDays = process.env.JWT_REFRESH_EXPIRES_DAYS ? 
      parseInt(process.env.JWT_REFRESH_EXPIRES_DAYS, 10) : 
      7; // Default 7 days
    
    expiresAt.setDate(expiresAt.getDate() + refreshExpireDays);
    
    // Create refresh token - hashedToken will be generated by model hook
    await RefreshToken.create({
      token: refreshToken,
      hashedToken: refreshToken, // This will be hashed by the model hook
      userId: user.id,
      expiresAt,
      ipAddress: req.ip,
      userAgent: req.headers['user-agent']
    });
    
    // Don't send password in response
    user.password = undefined;
    
    return res.status(201).json({
      success: true,
      data: {
        user,
        accessToken,
        refreshToken
      }
    });
  } catch (error) {
    next(error);
  }
};

// Login user
exports.login = async (req, res, next) => {
  try {
    const { email, password } = req.body;
    
    // Validate input
    if (!email || !password) {
      return res.status(400).json({
        success: false,
        message: 'Please provide email and password'
      });
    }
    
    // Check if user exists
    const user = await User.findOne({
      where: {
        email
      }
    });
    
    if (!user) {
      return res.status(401).json({
        success: false,
        message: 'Invalid credentials'
      });
    }
    
    // Check if password matches using the model's method
    const isMatch = await user.isValidPassword(password);
    
    if (!isMatch) {
      return res.status(401).json({
        success: false,
        message: 'Invalid credentials'
      });
    }
    
    // Update last login time
    await user.update({
      lastLogin: new Date()
    });
    
    // Generate tokens
    const { accessToken, refreshToken } = generateTokens(user);
    
    // Revoke all existing refresh tokens for this user
    await RefreshToken.update(
      { isRevoked: true },
      { where: { userId: user.id, isRevoked: false } }
    );
    
    // Save refresh token to RefreshToken model
    const expiresAt = new Date();
    // Parse refresh token expiration
    const refreshExpireDays = process.env.JWT_REFRESH_EXPIRES_DAYS ? 
      parseInt(process.env.JWT_REFRESH_EXPIRES_DAYS, 10) : 
      7; // Default 7 days
    
    expiresAt.setDate(expiresAt.getDate() + refreshExpireDays);
    
    // Create refresh token - hashedToken will be generated by model hook
    await RefreshToken.create({
      token: refreshToken,
      hashedToken: refreshToken, // This will be hashed by the model hook
      userId: user.id,
      expiresAt,
      ipAddress: req.ip,
      userAgent: req.headers['user-agent']
    });
    
    // Don't send password in response
    user.password = undefined;
    
    return res.status(200).json({
      success: true,
      data: {
        user,
        accessToken,
        refreshToken
      }
    });
  } catch (error) {
    next(error);
  }
};

// Refresh token
exports.refreshToken = async (req, res, next) => {
  try {
    // User and token are now provided by the verifyRefreshToken middleware
    const user = req.user;
    const tokenRecord = req.refreshToken;
    
    // Generate new tokens
    const tokens = generateTokens(user);
    
    // Revoke old refresh token
    await tokenRecord.update({ isRevoked: true });
    
    // Save new refresh token
    const expiresAt = new Date();
    // Parse refresh token expiration
    const refreshExpireDays = process.env.JWT_REFRESH_EXPIRES_DAYS ? 
      parseInt(process.env.JWT_REFRESH_EXPIRES_DAYS, 10) : 
      7; // Default 7 days
    
    expiresAt.setDate(expiresAt.getDate() + refreshExpireDays);
    
    // Create refresh token - hashedToken will be generated by model hook
    await RefreshToken.create({
      token: tokens.refreshToken,
      hashedToken: tokens.refreshToken, // This will be hashed by the model hook
      userId: user.id,
      expiresAt,
      ipAddress: req.ip,
      userAgent: req.headers['user-agent']
    });
    
    return res.status(200).json({
      success: true,
      data: tokens
    });
  } catch (error) {
    next(error);
  }
};

// Logout user
exports.logout = async (req, res, next) => {
  try {
    // Get token from header
    const authHeader = req.headers.authorization;
    const token = authHeader && authHeader.split(' ')[1];
    
    if (!token) {
      return res.status(400).json({
        success: false,
        message: 'Access token is required'
      });
    }
    
    // Revoke all refresh tokens for user
    await RefreshToken.update(
      { isRevoked: true },
      { where: { userId: req.user.id } }
    );
    
    // Add token to blacklist - for immediate access token invalidation
    // In a production system, you should store this in Redis or another fast cache
    // For now, we'll just use an in-memory solution
    global.revokedTokens = global.revokedTokens || new Set();
    global.revokedTokens.add(token);
    
    // Clean up old tokens occasionally (not for every request)
    if (Math.random() < 0.01) { // 1% chance to run cleanup
      const decoded = jwt.decode(token);
      const now = Math.floor(Date.now() / 1000);
      
      // Remove expired tokens from blacklist
      global.revokedTokens.forEach(t => {
        try {
          const payload = jwt.decode(t);
          if (payload.exp < now) {
            global.revokedTokens.delete(t);
          }
        } catch (err) {
          // Invalid token, remove it
          global.revokedTokens.delete(t);
        }
      });
    }
    
    return res.status(200).json({
      success: true,
      message: 'Logged out successfully'
    });
  } catch (error) {
    next(error);
  }
};

// Get current user
exports.getCurrentUser = async (req, res, next) => {
  try {
    const user = await User.findByPk(req.user.id);
    
    if (!user) {
      return res.status(404).json({
        success: false,
        message: 'User not found'
      });
    }
    
    // Don't send password in response
    user.password = undefined;
    
    return res.status(200).json({
      success: true,
      data: user
    });
  } catch (error) {
    next(error);
  }
};

// Helper function to generate tokens
const generateTokens = (user) => {
  // Create access token
  const accessToken = jwt.sign(
    { 
      id: user.id,
      email: user.email,
      role: user.role
    },
    JWT_SECRET,
    { expiresIn: JWT_EXPIRES_IN || '1h' }
  );
  
  // Create refresh token
  const refreshToken = jwt.sign(
    { id: user.id },
    JWT_REFRESH_SECRET || 'refresh-secret-key-fallback', // Fallback for testing only
    { expiresIn: JWT_REFRESH_EXPIRES_IN || '7d' }
  );
  
  return {
    accessToken,
    refreshToken
  };
}; 